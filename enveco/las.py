# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_las.ipynb (unless otherwise specified).

__all__ = ['las_to_df', 'field_plot_circular', 'calc_metrics']

# Cell
import laspy
import numpy as np
import pandas as pd

# Cell

def las_to_df(fn:str) -> pd.DataFrame:
    "Open .las-file and return it as dataframe with columns [x, y, z, num_returns, intensity]"
    lasfile = laspy.file.File(fn, mode='r')
    lidar_df = pd.DataFrame(columns=['x', 'y', 'z', 'num_returns', 'intensity'],
                            data=np.dstack((lasfile.x, lasfile.y, lasfile.z, lasfile.intensity, lasfile.num_returns))[0])
    lasfile.close()
    return lidar_df

def field_plot_circular(lidar_df:pd.DataFrame, plot_x:float, plot_y:float, radius:float=9) -> pd.DataFrame:
    "Select only the circular field plot area as valid lidar data"
    lidar_df = lidar_df[lidar_df.apply(lambda row:np.linalg.norm(np.array([row.x, row.y]).T - np.array([plot_x, plot_y]).T) <= 9, axis=1)]
    return lidar_df

def calc_metrics(lidar_df:pd.DataFrame, min_h:int=1.5) -> list:
    "Calculate typical LiDAR-metrics from dataframe containing lidar information"
    vege_df = lidar_df[lidar_df.z >= min_h]
    if len(vege_df) == 0: return None

    # Simple metrics
    hmax = vege_df.z.max() # maximum height
    hmean = vege_df.z.mean() # mean height
    hstd  = vege_df.z.std() # standard deviation for height
    pene = len(vege_df) / len(lidar_df) # penetration percentage
    cv = hstd / hmean # coefficient of variation
    imax = vege_df.intensity.max() # maximum intensity
    imean = vege_df.intensity.mean() # mean intensity
    imedian = vege_df.intensity.median() # median intensity

    # Height quantiles for returns above minimum height
    h10 = vege_df.z.quantile(0.1)
    h20 = vege_df.z.quantile(0.2)
    h30 = vege_df.z.quantile(0.3)
    h40 = vege_df.z.quantile(0.4)
    h50 = vege_df.z.quantile(0.5)
    h60 = vege_df.z.quantile(0.6)
    h70 = vege_df.z.quantile(0.7)
    h80 = vege_df.z.quantile(0.8)
    h90 = vege_df.z.quantile(0.9)
    h95 = vege_df.z.quantile(0.95)
    h98 = vege_df.z.quantile(0.98)
    h99 = vege_df.z.quantile(0.99)

    # Percentages of points in each height level above minimum height
    level = (hmax - min_h) * 0.1
    p_1 = vege_df[vege_df.z < (min_h + level)]
    p_2 = vege_df[vege_df.z < (min_h + 2 * level)]
    p_3 = vege_df[vege_df.z < (min_h + 3 * level)]
    p_4 = vege_df[vege_df.z < (min_h + 4 * level)]
    p_5 = vege_df[vege_df.z < (min_h + 5 * level)]
    p_6 = vege_df[vege_df.z < (min_h + 6 * level)]
    p_7 = vege_df[vege_df.z < (min_h + 7 * level)]
    p_8 = vege_df[vege_df.z < (min_h + 8 * level)]
    p_9 = vege_df[vege_df.z < (min_h + 9 * level)]
    p_95 = vege_df[vege_df.z < (min_h + 9.5 * level)]
    p_98 = vege_df[vege_df.z < (min_h + 9.8 * level)]
    p_99 = vege_df[vege_df.z < (min_h + 9.9 * level)]

    p10 = len(p_1)/len(vege_df)
    p20 = len(p_2)/len(vege_df)
    p30 = len(p_3)/len(vege_df)
    p40 = len(p_4)/len(vege_df)
    p50 = len(p_5)/len(vege_df)
    p60 = len(p_6)/len(vege_df)
    p70 = len(p_7)/len(vege_df)
    p80 = len(p_8)/len(vege_df)
    p90 = len(p_9)/len(vege_df)
    p95 = len(p_95)/len(vege_df)
    p98 = len(p_98)/len(vege_df)
    p99 = len(p_99)/len(vege_df)

    # number of points in each level
    p_no = len(vege_df)

    df_vals = [hmax, hmean, hstd, pene, cv, imax, imean, imedian,
               h10, h20, h30, h40, h50, h60, h70, h80, h90, h95, h98, h99,
               p10, p20, p30, p40, p50, p60, p70, p80, p90, p95, p98, p99, p_no]
    return df_vals