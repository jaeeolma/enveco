# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_las.ipynb (unless otherwise specified).

__all__ = ['plot_point_cloud', 'plot_2d_views', 'las_to_df', 'mask_plot_from_lidar', 'calc_height_features',
           'calc_intensity_features', 'height_cols', 'intensity_cols', 'calc_height_quantiles', 'quantile_cols',
           'calc_point_proportions', 'calc_point_features', 'point_cols', 'proportion_cols', 'calc_canopy_densities',
           'density_cols', 'voxel_grid_from_las']

# Cell
import laspy
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from itertools import product

# Cell
def plot_point_cloud(lasfile:laspy.file.File) -> plt.Axes:
    "Return 3d-projection of point cloud in ax"
    points = lasfile.points.copy()
    las_scaleX = lasfile.header.scale[0]
    las_scaleY = lasfile.header.scale[1]
    las_scaleZ = lasfile.header.scale[2]
    las_offsetX = lasfile.header.offset[0]
    las_offsetY = lasfile.header.offset[1]
    las_offsetZ = lasfile.header.offset[2]

    p_X = np.array((points['point']['X'] * las_scaleX) + las_offsetX)
    p_Y = np.array((points['point']['Y'] * las_scaleY) + las_offsetY)
    p_Z = np.array((points['point']['Z'] * las_scaleZ) + las_offsetZ)

    fig = plt.figure(figsize=(10,10))
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(p_X, p_Y, p_Z, c='r', marker='o')
    return ax

# Cell
def plot_2d_views(lasfile:laspy.file.File)-> plt.Axes:
    "Return X-Y, X-Z and Y-Z -views from lasfile"
    points = lasfile.points.copy()
    las_scaleX = lasfile.header.scale[0]
    las_scaleY = lasfile.header.scale[1]
    las_scaleZ = lasfile.header.scale[2]
    las_offsetX = lasfile.header.offset[0]
    las_offsetY = lasfile.header.offset[1]
    las_offsetZ = lasfile.header.offset[2]

    p_X = np.array((points['point']['X'] * las_scaleX) + las_offsetX)
    p_Y = np.array((points['point']['Y'] * las_scaleY) + las_offsetY)
    p_Z = np.array((points['point']['Z'] * las_scaleZ) + las_offsetZ)
    fig, axs = plt.subplots(1,3, figsize=(13,4))
    axs[0].scatter(p_X, p_Y)
    axs[0].grid()
    axs[0].set_title('X=lon, Y=lat')
    axs[1].scatter(p_X, p_Z)
    axs[1].grid()
    axs[1].set_title('X=lon, Y=height')
    axs[2].scatter(p_Y, p_Z)
    axs[2].grid()
    axs[2].set_title('X=lat, Y=height')
    return axs

# Cell

def las_to_df(fn:str) -> pd.DataFrame:
    """Open .las-file and return it as dataframe with columns [x, y, z, num_returns, intensity].
    Also convert point cloud to photogrammetric, meaning only one z-coordinate in each x-y -pair"""
    lasfile = laspy.file.File(fn, mode='r')
    lidar_df = pd.DataFrame(columns=['x', 'y', 'z', 'num_returns', 'intensity'],
                            data=np.dstack((lasfile.x, lasfile.y, lasfile.z, lasfile.num_returns, lasfile.intensity))[0])
    # Make sure we only have one value for each x,y -point (photogrammetric point cloud)
    lidar_df = lidar_df.drop_duplicates(['x','y'], keep='last')
    lasfile.close()
    return lidar_df

def mask_plot_from_lidar(lidar_df:pd.DataFrame, plot_x:float, plot_y:float, radius:float=9) -> pd.DataFrame:
    "Select only the circular field plot area as used lidar data, center point of plot is <plot_x, plot_y>"
    lidar_df = lidar_df[lidar_df.apply(lambda row:np.linalg.norm(np.array([row.x, row.y]).T - np.array([plot_x, plot_y]).T) <= 9, axis=1)]
    return lidar_df

# Cell

height_cols = ['hmax', 'hmean', 'hstd', 'cv']

def calc_height_features(lidar_df:pd.DataFrame, min_h:int=1.5) -> list:
    """Calculate height based features from dataframe from vegetation points (points with z-coordinate above `min_h`).
    Returns a list with maximum height, mean height, standard deviation for height and coefficient of variation for height
    """
    vege_df = lidar_df[lidar_df.z >= min_h]
    if len(vege_df) == 0: return None

    hmax = vege_df.z.max() # maximum height
    hmean = vege_df.z.mean() # mean height
    hstd  = vege_df.z.std() # standard deviation for height
    cv = hstd / hmean # coefficient of variation

    h_features = [hmax, hmean, hstd, cv]
    return h_features

intensity_cols = ['imax', 'imean', 'imedian']

def calc_intensity_features(lidar_df:pd.DataFrame, min_h:int=1.5) -> list:
    """Calculate intensity based features from vegetation points (points with z-coordinate above `min_h`).
    Returns a list with maximum intensity, mean intensity and median intensity
    """
    vege_df = lidar_df[lidar_df.z >= min_h]
    if len(vege_df) == 0: return None
    imax = vege_df.intensity.max() # maximum intensity
    imean = vege_df.intensity.mean() # mean intensity
    imedian = vege_df.intensity.median() # median intensity

    intensity_features = [imax, imean, imedian]
    return intensity_features

# Cell

quantile_cols = [f'h{int(q):02d}' for q in np.linspace(0,95, 20)] # last quantile is the same as hmax

def calc_height_quantiles(lidar_df:pd.DataFrame, min_h:int=1.5) -> list:
    "Calculate height quantiles for 5% intervals, feature 3"
    vege_df = lidar_df[lidar_df.z >= min_h]
    if len(vege_df) == 0: return None
    quantiles = [vege_df.z.quantile(q) for q in np.linspace(0,.95,20)]
    return quantiles

# Cell

point_cols = ['veg', 'veg_ground_ratio']
proportion_cols = [f'p{int(q):02d}' for q in np.linspace(0.05,95, 19)]

def calc_point_proportions(lidar_df:pd.DataFrame, min_h:int=1.5) -> list:
    "Calculate point proportions for points above quantiles H05, H10,..., H90, H95"
    vege_df = lidar_df[lidar_df.z >= min_h]
    if len(vege_df) == 0: return None
    quantiles = [vege_df.z.quantile(q) for q in np.linspace(0.05,.95,19)]
    proportions = [len(vege_df[vege_df.z >= q])/len(vege_df) for q in quantiles]
    return proportions

def calc_point_features(lidar_df:pd.DataFrame, min_h:int=1.5) -> list:
    "Calculate proportion of vegetation points and ratio between vegetation and ground points"
    vege_df = lidar_df[lidar_df.z >= min_h]
    if len(vege_df) == 0: return None
    # Proportion of vegetation points
    veg = len(vege_df) / len(lidar_df) # proportion of vegetation point

    # Proportion of ground points
    ground = (len(lidar_df)- len(vege_df)) / len(lidar_df)

    # Ratio between vegetation points and ground points
    veg_ground_ratio = len(vege_df) / (ground)
    point_features = [veg, veg_ground_ratio]
    return point_features

# Cell

def calc_canopy_densities(lidar_df:pd.DataFrame, min_h:int=1.5) -> list:
    """Divide the point cloud above `min_h` to 10 equal levels, and calculate D0,D1...D9,
    where Dx is the proportion of points in the interval [level_x, level_(x+1)]
    """
    vege_df = lidar_df[lidar_df.z >= min_h]
    if len(vege_df) == 0: return None
    levels = np.linspace(vege_df.z.min(),vege_df.z.max(),11)
    proportions = [len(vege_df[vege_df.z.between(levels[i], levels[i+1])]) / len(vege_df) for i in range(10)]
    return proportions

density_cols = [f'd{int(q):02d}' for q in np.linspace(0,90,10)]

# Cell
def voxel_grid_from_las(lasfile:laspy.file.File, plot_x:float, plot_y:float, bin_voxels:bool=False,
                        max_h:float=42., plot_size:float=9., bottom_voxels:bool=False, mask_plot:bool=False) -> np.ndarray:
    "Create voxel grid from lidar point cloud"
    coords = np.vstack((lasfile.x, lasfile.y, lasfile.z)).T
    min_vals = (plot_x-plot_size, plot_y-plot_size)

    # Should match to 1mx1mx1m voxels maybe
    num_bins = 19
    num_vert_bins = 43

    # Create bins and calculate histograms
    H, edges = np.histogramdd(coords, bins=(np.linspace(min_vals[0]-.001, min_vals[0] + 2*plot_size, num_bins + 1),
                                            np.linspace(min_vals[1]-.001, min_vals[1] + 2*plot_size, num_bins + 1),
                                            np.linspace(0, max_h, num_vert_bins+1)))

    if bin_voxels: H = np.where(H!=0,1,0)

    H = H.astype('int8')

    if bottom_voxels:
        for x, y in product(range(num_bins), range(num_bins)):
            if np.max(H[x,y]) == 0: max_idx_of_voxel = 0
            else:
                max_idx_of_voxel = np.argwhere(H[x,y] == np.max(H[x,y])).max()
            for z in range(max_idx_of_voxel+1):
                H[x,y,z] = 1

    if mask_plot:
        center = (int(H.shape[0]/2), int(H.shape[1]/2))
        X, Y = np.ogrid[:H.shape[0], :H.shape[1]]
        dist_from_center = np.sqrt((X-center[0])**2 + (Y-center[1])**2)
        mask = dist_from_center <= H.shape[0]/2
        H[~mask,:] = 0

    return H